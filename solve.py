from Crypto.Util.number import inverse

# Các giá trị đã cho
n = 8262484404039080234674464096892083649512125154907653766125355280462174467752365171520214019105260216635156342798776857769226977866293619511046744387281689
x = 12031416392805679236142766051898549142702963589759100480871285793865448632299983625351554820285275303762127309674270177717967326545202458638524142346095531
y = 12931680370259261587513896756599798037839193117419249893361514814557466255128720091564649345460871858457431079106319600074209695059298330868517852095473231
c = 193621561678255412194700199734953562400410084268832639707046155289781307266117020804400038647142959891790132613280304016827904877823282850315344334372350

# Tính nghịch đảo modular của x và y
t_inv_x = inverse(x, n)
t_inv_y = inverse(y, n)

# Giải mã m1 và m2
m1 = (c * t_inv_y) % n
m2 = ((c - m1 * x) * t_inv_y) % n

# Chuyển đổi từ số nguyên sang bytes
m1_bytes = long_to_bytes(m1)
m2_bytes = long_to_bytes(m2)

# Ghép lại chuỗi ban đầu
m = m1_bytes + m2_bytes
print(m.decode())
